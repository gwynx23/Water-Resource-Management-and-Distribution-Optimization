# -*- coding: utf-8 -*-
"""code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rkpotUnVQ7fpvp1FtX1ZGWjzwKT213x1
"""

import heapq

class WaterDistributionGraph:
    def __init__(self, vertices):
        self.V = vertices  # Number of vertices (water sources and barangays)
        self.graph = [[] for _ in range(vertices)]  # Adjacency list for the graph

    def add_edge(self, u, v, weight):
        # Add an edge to the graph (undirected)
        self.graph[u].append((v, weight))
        self.graph[v].append((u, weight))

    def dijkstra(self, source):
        # Initialize distances as infinite and visited as False
        distances = [float('inf')] * self.V
        distances[source] = 0
        priority_queue = [(0, source)]  # (distance, node)

        while priority_queue:
            current_distance, u = heapq.heappop(priority_queue)

            # Process each neighbor of the current node
            for neighbor, weight in self.graph[u]:
                distance = current_distance + weight

                # Only consider this path if it's better
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    heapq.heappush(priority_queue, (distance, neighbor))

        # Print the shortest path from the source to all nodes
        print("Vertex \t Distance from Source")
        for vertex in range(self.V):
            print(f"{vertex} \t {distances[vertex]}")

# Example setup for 5 barangays with water distribution paths
g = WaterDistributionGraph(5)
g.add_edge(0, 1, 2)  # Water source to barangay 1
g.add_edge(0, 3, 6)  # Water source to barangay 3
g.add_edge(1, 2, 3)  # Barangay 1 to barangay 2
g.add_edge(1, 4, 5)  # Barangay 1 to barangay 4
g.add_edge(2, 4, 7)  # Barangay 2 to barangay 4
g.add_edge(3, 4, 9)  # Barangay 3 to barangay 4

# Run Dijkstra's algorithm starting from the water source (node 0)
g.dijkstra(0)

"""# New Section"""